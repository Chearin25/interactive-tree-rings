<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>나이테 퍼지는 시</title>
    <style>
      body {
        margin: 0;
        background-color: #0e0e0e;
        color: white;
        font-family: 'Nanum Gothic', sans-serif;
        overflow: hidden;
      }
      #poem {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        text-align: center;
        font-size: 1.2rem;
        line-height: 2.2;
        opacity: 0;
        transition: opacity 2s;
        pointer-events: none;
        white-space: pre-line;
      }
      .ko {
        color: rgba(255, 255, 255, 0.4);
      }
      .en {
        color: rgba(255, 255, 255, 0.7);
      }
      .fr {
        color: rgba(255, 255, 255, 1);
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.js"></script>
    <div id="poem"></div>
    <script>
      let rings = [];
      let poemLines = [
        [
          "손끝에 얹어 차갑게 식어가는 숨결의 심장박동을 듣습니다.",
          "I hear the heartbeat of breath cooling on my fingertips.",
          "J'entends le battement du cœur du souffle refroidi au bout de mes doigts."
        ],
        [
          "모든 갈등의 뿌리는 확신이라 했습니다.",
          "They say all conflict stems from certainty.",
          "On dit que toute lutte naît de la certitude."
        ],
        [
          "흐르는 존재 속에서 나는 사라질 수 있을까.",
          "Can I disappear within the flowing existence?",
          "Puis-je disparaître dans l'existence fluide ?"
        ],
        [
          "기록되지 않은 고통은 어디로 사라질까요.",
          "Where does unrecorded pain vanish?",
          "Où disparaît la douleur non écrite ?"
        ],
        [
          "무너진 말들이 내 손끝에서 다시 피어난다.",
          "Broken words bloom again at my fingertips.",
          "Les mots brisés refleurissent au bout de mes doigts."
        ]
      ];
      let currentLine = 0;
      let lastRingTime = 0;

      function setup() {
        createCanvas(windowWidth, windowHeight);
        noFill();
        stroke(255, 80);
      }

      function draw() {
        background(14, 14, 14, 30);
        for (let i = rings.length - 1; i >= 0; i--) {
          rings[i].update();
          rings[i].display();
          if (rings[i].radius > width * 0.75) {
            rings.splice(i, 1);
          }
        }
      }

      function mouseMoved() {
        let now = millis();
        if (now - lastRingTime > 400) {
          rings.push(new Ring(mouseX, mouseY));
          lastRingTime = now;
          showNextLine();
        }
      }

      class Ring {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.radius = 5;
          this.alpha = 150;
        }
        update() {
          this.radius += 1.5;
          this.alpha -= 0.7;
        }
        display() {
          stroke(255, this.alpha);
          beginShape();
          for (let a = 0; a < TWO_PI; a += 0.2) {
            let offset = random(-1.5, 1.5);
            let r = this.radius + offset;
            let x = this.x + cos(a) * r;
            let y = this.y + sin(a) * r;
            vertex(x, y);
          }
          endShape(CLOSE);
        }
      }

      function showNextLine() {
        const poem = document.getElementById("poem");
        poem.style.opacity = 0;
        setTimeout(() => {
          const lines = poemLines[currentLine];
          poem.innerHTML = `<div class="ko">${lines[0]}</div>\n<div class="en">${lines[1]}</div>\n<div class="fr">${lines[2]}</div>`;
          poem.style.opacity = 1;
          currentLine = (currentLine + 1) % poemLines.length;
        }, 400);
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }
    </script>
  </body>
</html>
